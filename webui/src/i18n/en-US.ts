const enUS = {
  app: {
    title: "Telegram Button WebUI",
    subtitle: "Vue3 refactor with focus on layout & workflow editor.",
    language: "Language",
    menu: "Menu",
    locale: {
      "zh-CN": "中文",
      "en-US": "English",
    },
    tabs: {
      layout: "Menus & Layout",
      workflow: "Workflows",
      bot: "Bot Config",
      logs: "Execution Logs",
    },
    saveSuccess: "Saved successfully",
    saveFailed: "Save failed: {error}",
  },
  toolbar: {
    refresh: "Refresh",
    saveAll: "Save All",
    export: "Export JSON",
  },
  login: {
    title: "WebUI Login",
    subtitle: "Enter WebUI access token.",
    placeholder: "X-Auth-Token",
    submit: "Enter",
    submitting: "Verifying...",
    emptyToken: "Please enter token",
    authFailed: "Authentication failed",
  },
  buttons: {
    menus: "Menus",
    addMenu: "Add Menu",
    emptyMenus: "No menus yet.",
    menuName: "Name",
    menuHeader: "Header",
    deleteMenu: "Delete Menu",
    deleteMenuTitle: "Confirm Menu Deletion",
    deleteMenuMessage: "Delete menu {menuId}? Buttons in it will become unassigned.",
    rootProtected: "Root menu cannot be deleted",
    unassigned: "Unassigned Buttons",
    addButton: "Create Button",
    emptyUnassigned: "No unassigned buttons.",
    defaultMenuName: "New Menu",
    defaultMenuHeader: "New Menu Header",
    defaultButtonName: "New Button",
    editor: {
      createTitle: "Create Button",
      editTitle: "Edit Button",
      textLabel: "Label",
      typeLabel: "Type",
      create: "Create",
      save: "Save",
      deleteButton: "Delete",
      deleteButtonTitle: "Confirm Delete",
      deleteButtonMessage: "Warning: delete button “{name}” permanently?<br><br>This cannot be undone.",
      removeFromMenu: "Remove from Menu",
      removeFromMenuTitle: "Confirm Removal",
      removeFromMenuMessage: "Remove this button from menu “{menuId}”?",
      idFailed: "Failed to generate ID: {error}",
      idFallback: "Failed to generate ID. Local ID used: {id}\nError: {error}",
      types: {
        command: "Command",
        url: "URL",
        submenu: "Submenu",
        webApp: "WebApp",
        action: "Action",
        workflow: "Workflow",
        inlineQuery: "Insert Text",
        switchInline: "Switch Inline Query",
        raw: "Raw Callback",
      },
      payload: {
        selectPlaceholder: "(Select)",
        command: "Command",
        url: "URL",
        submenu: "Target Menu",
        webApp: "WebApp",
        action: "Action",
        workflow: "Workflow",
        inlineQuery: "Insert Text",
        switchInline: "Query",
        raw: "Callback Data",
      },
    },
  },
  workflow: {
    title: "Workflow Editor",
    description: "Description",
    create: "New",
    save: "Save Workflow",
    remove: "Delete",
    defaultName: "New Workflow",
    createSuccess: "Workflow created",
    actionPrefixLocal: "[Local]",
    emptyState: {
      title: "No workflows",
      description: "Click “New” above to create your first workflow.",
      action: "Create workflow",
    },
    paletteTitle: "Modular Actions",
    paletteSubtitle: "Drag action nodes to the canvas.",
    paletteSearch: "Search actions...",
    paletteSearchAria: "Search modular actions",
    searchPlaceholder: "Search actions...",
    paletteUpload: "Upload",
    paletteList: "Available actions",
    paletteCollapse: "Collapse list",
    selectorAria: "Select workflow",
    nameLabel: "Workflow name",
    namePlaceholder: "Enter workflow name",
    selectPlaceholder: "(Select)",
    zoomLabel: "Canvas Zoom",
    zoomOut: "Zoom Out",
    zoomIn: "Zoom In",
    zoomReset: "Reset Zoom",
    nodeEdit: "Edit Node",
    nodeMissing: "Action definition not found.",
    advancedJson: "Advanced: Raw JSON",
    useRawJson: "Save using raw JSON",
    jsonParseFailed: "JSON parse failed: {error}",
    nodeModal: {
      tabs: {
        params: "Inputs",
        wiring: "Wiring",
        advanced: "Advanced",
      },
      modes: {
        literal: "Value",
        wire: "Wire",
        ref: "Ref",
      },
      params: {
        current: "Current",
        notConnected: "Not connected",
        openWiringBoard: "Open wiring board",
        pickUpstreamOutput: "Pick upstream output",
        pickUpstreamField: "Pick upstream field",
        refPreviewSingle: "Ref: {expr}",
        refPreviewMulti: "Ref: {expr} ({count} matches)",
        toRef: "Convert to ref",
        disconnect: "Disconnect",
      },
      paramsPanel: {
        searchPlaceholder: "Search inputs…",
        empty: "This node has no configurable inputs.",
        emptyFiltered: "No matching inputs.",
      },
      wiring: {
        hint: "Tip: select a left output, then click “Connect” on the right input. You can also drag to connect.",
        upstreamSearchPlaceholder: "Search upstream outputs/nodes…",
        inputsSearchPlaceholder: "Search inputs…",
        onlyConnected: "Connected only",
        showWires: "Show wires",
        focusOnly: "Focus only",
        upstreamTitle: "Upstream outputs",
        upstreamEmpty: "No upstream outputs available. Connect upstream nodes with control edges first.",
        noMatchingUpstream: "No matching upstream outputs.",
        noMatchingInputs: "No matching inputs.",
        sourceTitle: "Source",
        noneSelected: "None",
        sourcePathPlaceholder: "Optional path, e.g. raw_event.message.text",
        clear: "Clear",
        inputsTitle: "Node inputs",
        connect: "Connect",
        path: "Path",
        pathPlaceholder: "Optional path",
      },
      upstreamPicker: {
        title: "Pick upstream field",
        upstreamNode: "Upstream node",
        upstreamNodePlaceholder: "Select upstream node (control ancestors)",
        subpathPlaceholder: "Optional extra path, e.g. raw_event.message.text",
        currentSelection: "Selected",
        previewPlaceholder: "Expression preview (auto-generated)",
        none: "None",
        noUpstream: "No control-upstream nodes available. Ref/wire cannot be created.",
        applyAsWire: "Apply as wire",
        applyAsRef: "Apply as ref",
      },
    },
    legacy: {
      paletteSearchMissing: "Palette search input #nodePaletteSearch is missing, search filtering disabled.",
      uploadControlMissing: "Upload controls missing; cannot upload modular actions from the UI.",
      authFailed: "Authentication failed. Please log in again.",
      addNodeMissingAction: "Cannot create node on canvas: missing action definition or ID.",
      noDescription: "No description",
      download: "Download",
      delete: "Delete",
      actionId: "Action ID",
      downloadFailed: "Download failed: {error}",
      deleteActionSuccess: "Action '{name}' deleted. The page will refresh.",
      deleteActionFailed: "Delete failed: {error}",
      passwordRequired: "Password required",
      deletePasswordPrompt: "Secure password enabled. Enter password to delete:",
      passwordPlaceholder: "Enter password...",
      deleteCancelled: "Delete cancelled.",
      deleteActionConfirmTitle: "Confirm deletion",
      deleteActionConfirmMessage: "Delete modular action “{name}” permanently?<br><br>This cannot be undone.",
      actionListInvalid: "Action list data is invalid.",
      actionListEmptyFiltered: "No actions matched “{term}”.",
      actionListEmptyAll: "No modular actions available.",
      uploadSuccess: "Action '{name}' uploaded. The page will refresh to sync.",
      uploadFailed: "Upload failed: {error}",
      uploadPasswordPrompt: "Upload password enabled. Enter password to upload:",
      uploadCancelled: "Upload cancelled.",
      descriptionTitle: "Description: {description}",
      descriptionEmptyTitle: "Add a description for this workflow",
      descriptionEditTitle: "Edit description",
      descriptionEditPrompt: "Enter a description for this workflow:",
      descriptionEditPlaceholder: "(Optional) Briefly describe what this workflow does.",
      descriptionPromptFallback: "Enter workflow description:",
      paletteExpandAria: "Expand modular action list",
      paletteCollapseAria: "Collapse modular action list",
      paletteExpandLabel: "Expand list",
      paletteCollapseLabel: "Collapse list",
      paletteStateReadFailed: "Failed to read palette collapse state; defaulting to expanded.",
      paletteStateSaveFailed: "Failed to save palette collapse state.",
      workflowSelectPlaceholder: "-- Select workflow --",
      workflowNameEmpty: "Workflow name cannot be empty.",
      workflowNameInvalid: "Invalid workflow name. Please enter valid characters.",
      nodeMissingAction: "Node {id} is missing action data and will be skipped.",
      saveFailed: "Save failed: {error}",
      saveSuccess: "Workflow “{name}” saved!",
      loadFailed: "Failed to load workflow",
      actionDefinitionMissing: "Action ID {id} not found; node {nodeId} will be skipped.",
      connectionMissingNode: "Cannot create connection; source or target node missing: {edgeId}",
      connectionPortMissing: "Cannot find connection ports: {edgeId}",
      loadWorkflowErrorAlert: "Load failed. See console for details.",
      deleteWorkflowSelectFirst: "Please select a workflow to delete.",
      deleteWorkflowConfirmTitle: "Confirm deletion",
      deleteWorkflowConfirmMessage: "Delete workflow “{name}” permanently?<br><br>This cannot be undone.",
      deleteWorkflowSuccess: "Workflow “{name}” deleted.",
      loadWorkflowConfirmTitle: "Confirm load",
      loadWorkflowConfirmMessage: "Loading a new workflow will overwrite unsaved changes. Continue?",
      newWorkflowConfirmTitle: "Confirm new workflow",
      newWorkflowConfirmMessage: "Create a new workflow?<br><br>Unsaved changes on the canvas will be lost.",
      updateNodeConfigMissing: "Failed to update node config: node ID {id} not found.",
      getNodeFailed: "Error while getting node {id}:",
    },
  },
  logs: {
    title: "Execution Logs",
    subtitle: "Inspect recent workflow runs to debug inputs/outputs and timing.",
    config: {
      title: "Observability",
      enabled: "Enabled",
      enabledHint: "When enabled, keep the latest N execution traces in storage.",
      keep: "Keep",
      includeInputs: "Record Inputs",
      includeOutputs: "Record Outputs",
      includeRuntime: "Record Runtime Context",
      save: "Save",
      reload: "Reload",
      loadFailed: "Failed to load config: {error}",
      saveSuccess: "Config saved",
      saveFailed: "Failed to save config: {error}",
    },
    list: {
      title: "Executions",
      total: "{total} total",
      refresh: "Refresh",
      clear: "Clear",
      clearConfirm: "Clear all execution logs?",
      searchPlaceholder: "Search id/workflow/error/user...",
      workflowPlaceholder: "Filter workflow (optional)",
      statusPlaceholder: "Filter status",
      limit: "Limit",
      empty: "No execution logs.",
      loadFailed: "Failed to load executions: {error}",
      cleared: "Execution logs cleared",
      clearFailed: "Failed to clear: {error}",
    },
    table: {
      status: "Status",
      workflow: "Workflow",
      time: "Time",
      duration: "Duration",
      chat: "Chat",
      user: "User",
      id: "ID",
    },
    detail: {
      title: "Execution Detail",
      open: "Open",
      refresh: "Refresh",
      delete: "Delete",
      deleteConfirm: "Delete this execution log?",
      loading: "Loading...",
      summary: "Summary",
      triggerType: "Trigger",
      awaitNode: "Await Node",
      error: "Error",
      nodes: "Node Trace",
      inputs: "Inputs",
      outputs: "Outputs",
      finalResult: "Final Result",
      empty: "No data.",
      loadFailed: "Failed to load detail: {error}",
      deleted: "Execution log deleted",
      deleteFailed: "Failed to delete: {error}",
    },
    status: {
      all: "All",
      success: "Success",
      error: "Error",
      pending: "Pending",
      skipped: "Skipped",
    },
  },
  bot: {
    title: "Bot Configuration",
    subtitle: "Configure bot token, webhook URL, and command list.",
    tokenLabel: "Bot Token",
    tokenPlaceholder: "Paste BotFather token",
    tokenFromEnv: "Using token from Worker environment variables.",
    tokenFromConfig: "Using token stored in WebUI.",
    tokenMissing: "Token is missing; Telegram actions will fail.",
    webhookLabel: "Webhook URL",
    webhookHelp: "Saving config calls setWebhook without options. Use the button below for options.",
    webhookFill: "Use current URL",
    webhookCopy: "Copy",
    copySuccess: "Copied to clipboard",
    copyFailed: "Copy failed: {error}",
    webhookOptionsLabel: "Webhook Options",
    webhookDropPending: "Drop pending updates",
    webhookSecretPlaceholder: "secret_token (optional)",
    webhookMaxConnectionsPlaceholder: "max_connections (1-100)",
    webhookAllowedUpdatesPlaceholder: "allowed_updates (e.g. message, callback_query)",
    webhookOptionsHelp: "Leave empty to use Telegram defaults.",
    webhookSet: "Set Webhook",
    webhookSetSuccess: "Webhook set successfully",
    webhookSetFailed: "Set webhook failed: {error}",
    webhookInfoTitle: "Webhook Status",
    webhookInfoRefresh: "Refresh status",
    webhookInfoEmpty: "Webhook info not loaded yet.",
    webhookInfoFailed: "Get webhook info failed: {error}",
    webhookStatusLabel: "Status",
    webhookStatusActive: "Active",
    webhookStatusMissing: "Not set",
    webhookInfoUrl: "URL",
    webhookInfoPending: "Pending updates",
    webhookInfoLastErrorDate: "Last error time",
    webhookInfoLastErrorMessage: "Last error message",
    webhookInfoMaxConnections: "Max connections",
    webhookInfoAllowedUpdates: "Allowed updates",
    webhookInfoIpAddress: "Webhook IP",
    webhookInfoCustomCert: "Custom certificate",
    tester: {
      title: "Mock Update Tester",
      hint: "Send a simulated request to /telegram/webhook for quick trigger and log validation.",
      workflowLabel: "Workflow",
      workflowPlaceholder: "Select workflow to execute",
      templateLabel: "Template",
      templateWorkflowCommand: "Run by Workflow Command",
      templateCallbackWorkflow: "Callback Button (Workflow)",
      templateMessageKeyword: "Keyword Message",
      fillTemplate: "Fill Template",
      payloadLabel: "Update JSON",
      payloadPlaceholder: "Input Telegram Update JSON",
      send: "Send Test Request",
      responseLabel: "Response",
      workflowRequired: "Please select a workflow first",
      sendSuccess: "Test request sent",
      sendFailed: "Test request failed: {error}",
      invalidJson: "Invalid JSON: {error}",
    },
    commandsTitle: "Commands",
    commandsHelp: "Register commands via setMyCommands (command without leading /).",
    commandsHelpArgs: "Optionally bind a workflow; arguments are injected into command_args / command_params.",
    commandsEmpty: "No commands yet",
    commandLabel: "Command",
    descriptionLabel: "Description",
    workflowLabel: "Workflow",
    workflowUnbound: "Unbound (register only)",
    argModeLabel: "Arg Mode",
    argModeAuto: "Auto detect",
    argModeText: "Split by spaces",
    argModeKv: "Key=Value",
    argModeJson: "JSON",
    argsSchemaLabel: "Args Schema",
    argsSchemaPlaceholder: "e.g. city, date",
    argsSchemaHint: "Optional: map ordered args into command_params via comma-separated keys.",
    commandPlaceholder: "start",
    descriptionPlaceholder: "Description",
    addCommand: "Add Command",
    removeCommand: "Remove",
    syncCommands: "Sync from Telegram",
    syncSuccess: "Synced successfully, please save config.",
    syncFailed: "Sync failed: {error}",
    saveConfig: "Save Config",
    saveSuccess: "Config saved",
    saveFailed: "Save failed: {error}",
    registerCommands: "Register Commands",
    registerSuccess: "Commands registered",
    registerFailed: "Register failed: {error}",
    loadFailed: "Failed to load config: {error}",
  },
  common: {
    unnamed: "Unnamed",
    ok: "OK",
    confirm: "Confirm",
    cancel: "Cancel",
    notice: "Notice",
    error: "Error",
  },
};

export default enUS;
